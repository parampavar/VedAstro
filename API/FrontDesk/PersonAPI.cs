using Microsoft.Azure.Functions.Worker;
using Microsoft.Azure.Functions.Worker.Http;
using VedAstro.Library;
using Person = VedAstro.Library.Person;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace API
{
    /// <summary>
    /// API Functions related to Person Profiles
    /// </summary>
    public class PersonAPI
    {

        #region PERSON

        /// <summary>
        /// Add new person to DB,
        /// returns ID of newly created person so caller can get use it
        /// http://localhost:7071/api/Calculate/AddPerson/OwnerId/xxx/Location/Singapore/Time/00:00/24/06/2024/+08:00/PersonName/James%20Brown/Gender/Male/Notes/%7Brodden:%22AA%22%7D
        /// </summary>
        public static async Task<string> AddPerson(string ownerId, Time birthTime, string personName, Gender gender, string notes = "", bool failIfDuplicate = false)
        {
            //don't allow add for public person's
            if (ownerId == "101") { throw new Exception("You can not add/edit public profiles with ID 101"); }

            //special ID made for human brains 🧠 (unique in whole DB)
            var brandNewHumanReadyId = await PersonManagerTools.GeneratePersonId(ownerId, personName, birthTime.StdYearText, failIfDuplicate);

            //make new person
            var newPerson = new Person(ownerId, brandNewHumanReadyId, personName, birthTime, gender, notes);

            //possible old cache of person with same id lived, so clear cache if any
            //delete data related to person (NOT USER, PERSON PROFILE)
            await AzureCache.DeleteCacheRelatedToPerson(newPerson);

            //creates record if no exist, update if already there
            AzureTable.PersonList.UpsertEntity(newPerson.ToAzureRow());

            //return ID of newly created person so caller can use it
            return newPerson.Id;

        }

        /// <summary>
        /// Note "Timezone not respected"
        /// </summary>
        public static async Task<string> UpdatePerson(string ownerId, string personId, Time birthTime, string personName, Gender gender, string notes = "")
        {
            //don't allow add for public person's
            if (ownerId == "101") { throw new Exception("You can not add/edit public profiles with ID 101"); }

            //pack the data
            var personParsed = new Person(ownerId, personId, personName, birthTime, gender, notes);

            //delete data related to person (NOT USER, PERSON PROFILE)
            await AzureCache.DeleteCacheRelatedToPerson(personParsed);

            //person updated based on Person ID which is immutable
            await AzureTable.PersonList?.UpsertEntityAsync(personParsed.ToAzureRow());

            return "Updated!";

        }

        /// <summary>
        /// Deletes a person's record, uses hash to identify person
        /// Note : user id is not checked here because Person hash
        /// can't even be generated by client side if you don't have access.
        /// Theoretically anybody who gets the hash of the person,
        /// can delete the record by calling this API
        /// </summary>
        public static async Task<string> DeletePerson(string ownerId, string personId)
        {
            //# get full person copy to place in recycle bin
            //query the database
            var foundCalls = AzureTable.PersonList?.Query<PersonListEntity>(row => row.PartitionKey == ownerId && row.RowKey == personId);
            //make into readable format
            var personAzureRow = foundCalls?.FirstOrDefault();
            var personToDelete = Person.FromAzureRow(personAzureRow);

            //# delete data related to person (NOT USER, PERSON PROFILE)
            await AzureCache.DeleteCacheRelatedToPerson(personToDelete);

            //# add deleted person to recycle bin
            //await AzureTable.PersonListRecycleBin.UpsertEntityAsync(personAzureRow);

            //# do final delete from MAIN DATABASE
            await AzureTable.PersonList.DeleteEntityAsync(ownerId, personId);

            return "Updated!";

        }

        /// <summary>
        /// Gets person list, with auto swap persons from visitor to logged in account if user id is not 101
        /// if user id is 101 (guest), then visitor id can be ommited on call
        /// </summary>
        public static async Task<JArray> GetPersonList(string ownerId, string visitorId = "")
        {
            //STAGE 1 : swap visitor ID with user ID if any (data follows user when log in)
            await SwapUserId(ownerId, visitorId);

            //get raw person data from main person list (partial without life events)
            var foundCalls = AzureTable.PersonList.Query<PersonListEntity>(call => call.PartitionKey == ownerId);

            //convert partial Person data to full Person with life events
            var personJsonList = new JArray();
            foreach (var call in foundCalls) { personJsonList.Add(Person.FromAzureRow(call).ToJson()); }

            //send to caller
            return personJsonList;

            //------LOCAL FUNCS-----------

            async Task SwapUserId(string ownerId, string visitorId)
            {
                //if both same no swap needed
                if (ownerId == visitorId) { return; }

                //if not yet logged in then skip
                if (ownerId == "101" || ownerId == null) { return; }

                //get all person's under visitor id
                var visitorIdPersons = AzureTable.PersonList.Query<PersonListEntity>(call => call.PartitionKey == visitorId);

                //if no records, then end here
                if (!visitorIdPersons.Any()) { return; }

                //transfer each person one by one
                foreach (var personOriRecord in visitorIdPersons)
                {
                    //1: make duplicate record with new owner id
                    //overwrite visitor id with user id
                    var modifiedPerson = personOriRecord.Clone();
                    modifiedPerson.PartitionKey = ownerId;
                    AzureTable.PersonList.AddEntity(modifiedPerson);

                    //2: delete original "visitor" record 
                    await AzureTable.PersonList.DeleteEntityAsync(personOriRecord.PartitionKey, personOriRecord.RowKey);
                }

            }

        }

        /// <summary>
        /// Generates hash to verify if list client has is up to date
        /// </summary>
        public static async Task<string> GetPersonListHash(string ownerId, string visitorId = "")
        {
            // Call GetPersonList to get the list of persons
            var personList = await GetPersonList(ownerId, visitorId);

            // Initialize a string to hold the concatenated data
            var concatenatedData = string.Empty;

            // Concatenate the data of all persons in the list
            foreach (var person in personList)
            {
                concatenatedData += person["PersonId"].ToString() +
                                    person["Name"].ToString() +
                                    person["BirthTime"].ToString() +
                                    person["Notes"].ToString();
            }

            // Generate a SHA256 hash of the concatenated data
            using var sha256 = System.Security.Cryptography.SHA256.Create();
            var bytes = sha256.ComputeHash(System.Text.Encoding.UTF8.GetBytes(concatenatedData));

            // Convert the hash to a hexadecimal string
            var hash = BitConverter.ToString(bytes).Replace("-", "").ToLowerInvariant();

            return hash;
        }

        /// <summary>
        /// Given a person id will get person's data, owner id is needed for privacy protection
        /// </summary>
        public static async Task<Person> GetPerson(string ownerId, string personId)
        {
            //get person from database matching user & owner ID (also checks shared list)
            var foundPerson = Tools.GetPersonById(personId, ownerId);

            //send person to caller
            return foundPerson;
        }

        /// <summary>
        /// Intelligible gets a person's image
        /// </summary>
        //public static async Task<byte[]> GetPersonImage(string personId)
        //{

        //    //start with backup person if all fails
        //    var personToImage = Person.Empty;
        //    BlobClient imageFile = null;

        //    try
        //    {
        //        //OPTION 1
        //        //check directly if custom uploaded image exist, if got end here
        //        var imageFound = await Tools.IsCustomPersonImageExist(personId);

        //        if (imageFound)
        //        {
        //            imageFile = Tools.GetPersonImage(personId);
        //            using var stream = new MemoryStream();
        //            await imageFile.DownloadToAsync(stream);
        //            stream.Position = 0;
        //            var byteArray = stream.ToArray();
        //            return byteArray;
        //        }

        //        //OPTION 2 : GET AZURE SEARCHED IMAGED
        //        else
        //        {
        //            //get the person record by ID
        //            personToImage = Tools.GetPersonById(personId);
        //            byte[] foundImage = await Tools.GetSearchImage(personToImage); //gets most probable fitting person image

        //            //save copy of image under profile, so future calls don't spend BING search quota
        //            await Tools.SaveNewPersonImage(personToImage.Id, foundImage);

        //            //return gotten image as is
        //            return foundImage;

        //        }

        //    }

        //    //OPTION 3 : USE ANONYMOUS IMAGE
        //    //used only when bing and saved records fail
        //    catch (Exception e)
        //    {

        //        //get default male or female image
        //        imageFile = personToImage.Gender == Gender.Male ? Tools.GetPersonImage("male") : Tools.GetPersonImage("female");

        //        //save copy of image under profile, so future calls don't spend BING search quota
        //        await Tools.SaveNewPersonImage(personToImage.Id, imageFile);

        //        //send person image to caller
        //        using var stream = new MemoryStream();
        //        await imageFile.DownloadToAsync(stream);
        //        stream.Position = 0;
        //        var byteArray = stream.ToArray();
        //        return byteArray;
        //    }


        //}


        #endregion
    }
}
